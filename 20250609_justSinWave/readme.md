## 雨音の音響合成の原理
- ランダム性:
	- 雨音は自然現象であるため、不規則なリズムやピッチの要素を持っています。
	- ノイズ（白色ノイズやピンクノイズ）を使用し、それをフィルタリングすることで雨音のベースを作ります。
- 粒状音響（Granular Synthesis）:
	- 雨粒が地面や屋根に当たる音は短いインパルス（粒状の音）の集まりとして表現できます。
	- ランダムなタイミングや音量で多数のインパルスを再生します。
- フィルタリング:
	- 雨音には低音成分が少なく、高音成分が多い傾向があります。
	- ハイパスフィルターやバンドパスフィルターを使用して音を調整します。
- リバーブ（Reverb）:
	- 雨音は反響を伴うことが多いため、適度なリバーブを加えるとリアリティが増します。
- ランダムな位置で雨粒を再生:ステレオ空間を利用して、左右からランダムに音を鳴らす。p5.Pannerを使用すると簡単に実現可能。
- 雨粒が大きいほど低い音、小さいほど高い音が鳴る。

## 雨のアニメーション
- 雨粒が地面にぶつかると、スプラッシュ効果が発生し、落ちた位置に一瞬だけ小さな光の粒が点滅する。
- パラメータ
	- 雨粒の速さや大きさをランダムに変える。重さや落下速度が粒ごとに違う感じを演出。
	- 雨粒が途中で風に流されて、斜めに落ちるように見せる。
- 構図: 窓の四角い枠が画面に大きく描かれ、その向こうに雨が降るシーン。
- 表現:
	- 雨粒が窓ガラスに当たって、垂れる動きを描写。
	- 雨粒が一度に垂れるのではなく、いくつかが途中で合流して太いしずくになる。
	- 風で雨粒が左右に揺れる動きも追加。
- 追加演出:
	- 窓の外には街灯や建物がぼやけた背景として描かれる。
	- 雨粒が窓枠を過ぎて落ちる際、軽い「しずく音」を再生
	
シミュレーション
1. 雨粒の生成と動きの基本
- 初期位置と方向:
	- 雨粒は窓ガラスの上部や中間あたりにランダムに生成される。
	- 落ちる方向は重力に応じて「ほぼ垂直」、ただし風の影響で少し斜めに揺れる。
- 速度:
	- 雨粒は「重さ」をランダムに設定し、重い粒ほど速く、軽い粒はゆっくり落ちる。
	- 速度はフレームごとに徐々に加速（重力効果）する。

2. しずくが垂れる動き
- 重力の影響:
	- 雨粒が垂れ落ちる速度は徐々に増加。
	- Y軸方向の速度 velocityY は時間とともに加算される。
- 分岐点の発生:
	- 雨粒が他の粒と近づいた場合、合流して1つの大きな粒になる。
	- 粒の大きさは合流するたびに増加。
- 抵抗のシミュレーション:
	- 粒が窓ガラスを垂れる際、ガラスの抵抗によって速度が緩やかになる（特に小さな粒）。
	- 抵抗効果を「摩擦値」として速度計算に加える。

3. 風の影響
- X軸の揺れ:
	- 窓ガラスに当たった雨粒は、風の影響でX方向に左右に少し動く。
	- 動きは簡単なサイン波`windOffset = amplitude * sin(frequency * time)`でランダムに変化。
	- 実装例:`drop.x += windStrength * sin(frameCount * windFrequency);`

4. しずくがガラスから消える動き
- 落下完了:
	- 雨粒がガラスの端（例えば画面の下部）に達したら、粒を消去。
	- または粒が小さくなって消える演出を追加。
- 乾燥エフェクト:雨粒が一定の位置に留まる場合、徐々に小さくして消滅。

5. ランダムな粒の合流と分裂
- 合流:
	- 雨粒同士が一定距離に近づくと1つに統合。
	- 合流した粒の大きさは元の粒の合計に応じて変化。
- 分裂（オプション）:窓ガラスの特定の場所で粒が「弾ける」ように分裂し、小さな粒が飛び散る。

6. エッジケース
- 粒が窓枠に当たる場合:
	- 窓枠に近づいた粒は、その位置で止まるか別方向に流れる。
	- 窓枠にしずくがたまる演出を追加するのも面白い。

コード例（基本シミュレーション）
```js
let drops = [];

function setup() {
	createCanvas(400, 400);
	for (let i = 0; i < 20; i++) {
		drops.push(new RainDrop(random(width), random(height / 2)));
	}
}

function draw() {
	background(30, 30, 100);

	for (let drop of drops) {
		drop.update();
		drop.show();
	}
}

class RainDrop {
	constructor(x, y) {
		this.x = x;
		this.y = y;
		this.size = random(5, 10);
		this.velocityY = random(1, 2);
		this.windOffset = 0;
	}

	update() {
		// Gravity effect
		this.velocityY += 0.1; // Simulating gravity
		this.y += this.velocityY;

		// Wind effect (optional)
		this.windOffset = 2 * sin(frameCount * 0.05);
		this.x += this.windOffset;

		// Reset when drop reaches the bottom
		if (this.y > height) {
			this.y = random(-50, 0);
			this.x = random(width);
			this.velocityY = random(1, 2);
		}
	}

	show() {
		noStroke();
		fill(200, 200, 255, 200);
		ellipse(this.x, this.y, this.size, this.size * 1.5);
	}
}
```
